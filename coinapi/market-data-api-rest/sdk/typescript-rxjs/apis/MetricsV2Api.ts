// tslint:disable
/**
 * CoinAPI Market Data REST API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * Contact: support@apibricks.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Observable } from 'rxjs';
import type { AjaxResponse } from 'rxjs/ajax';
import { BaseAPI, throwIfNullOrUndefined } from '../runtime';
import type { OperationOpts, HttpHeaders, HttpQuery } from '../runtime';
import type {
    V1MetricInfo,
} from '../models';

export interface MarketdataListMetricsV2AssetHistoryRequest {
    metricId: string;
    assetId: string;
    timeStart?: string;
    timeEnd?: string;
    timeFormat?: string;
    periodId?: string;
    limit?: number;
}

export interface MarketdataListMetricsV2AssetListingRequest {
    assetId: string;
}

export interface MarketdataListMetricsV2ChainHistoryRequest {
    metricId: string;
    chainId: string;
    timeStart?: string;
    timeEnd?: string;
    timeFormat?: string;
    periodId?: string;
    limit?: number;
}

export interface MarketdataListMetricsV2ChainListingRequest {
    chainId: string;
}

export interface MarketdataListMetricsV2ExchangeHistoryRequest {
    metricId: string;
    exchangeId: string;
    timeStart?: string;
    timeEnd?: string;
    timeFormat?: string;
    periodId?: string;
    limit?: number;
}

export interface MarketdataListMetricsV2ExchangeListingRequest {
    exchangeId: string;
}

/**
 * no description
 */
export class MetricsV2Api extends BaseAPI {

    /**
     * Get asset metrics history.
     * Historical metrics for the asset
     */
    marketdataListMetricsV2AssetHistory({ metricId, assetId, timeStart, timeEnd, timeFormat, periodId, limit }: MarketdataListMetricsV2AssetHistoryRequest): Observable<Array<object>>
    marketdataListMetricsV2AssetHistory({ metricId, assetId, timeStart, timeEnd, timeFormat, periodId, limit }: MarketdataListMetricsV2AssetHistoryRequest, opts?: OperationOpts): Observable<AjaxResponse<Array<object>>>
    marketdataListMetricsV2AssetHistory({ metricId, assetId, timeStart, timeEnd, timeFormat, periodId, limit }: MarketdataListMetricsV2AssetHistoryRequest, opts?: OperationOpts): Observable<Array<object> | AjaxResponse<Array<object>>> {
        throwIfNullOrUndefined(metricId, 'metricId', 'marketdataListMetricsV2AssetHistory');
        throwIfNullOrUndefined(assetId, 'assetId', 'marketdataListMetricsV2AssetHistory');

        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // APIKey authentication
        };

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'metric_id': metricId,
            'asset_id': assetId,
        };

        if (timeStart != null) { query['time_start'] = (timeStart as any).toISOString(); }
        if (timeEnd != null) { query['time_end'] = (timeEnd as any).toISOString(); }
        if (timeFormat != null) { query['time_format'] = timeFormat; }
        if (periodId != null) { query['period_id'] = periodId; }
        if (limit != null) { query['limit'] = limit; }

        return this.request<Array<object>>({
            url: '/v2/metrics/asset/history',
            method: 'GET',
            headers,
            query,
        }, opts?.responseOpts);
    };

    /**
     * Get all metrics that are actually available for the specified asset.
     * Listing of metrics available for specific asset
     */
    marketdataListMetricsV2AssetListing({ assetId }: MarketdataListMetricsV2AssetListingRequest): Observable<Array<V1MetricInfo>>
    marketdataListMetricsV2AssetListing({ assetId }: MarketdataListMetricsV2AssetListingRequest, opts?: OperationOpts): Observable<AjaxResponse<Array<V1MetricInfo>>>
    marketdataListMetricsV2AssetListing({ assetId }: MarketdataListMetricsV2AssetListingRequest, opts?: OperationOpts): Observable<Array<V1MetricInfo> | AjaxResponse<Array<V1MetricInfo>>> {
        throwIfNullOrUndefined(assetId, 'assetId', 'marketdataListMetricsV2AssetListing');

        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // APIKey authentication
        };

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'asset_id': assetId,
        };

        return this.request<Array<V1MetricInfo>>({
            url: '/v2/metrics/asset/listing',
            method: 'GET',
            headers,
            query,
        }, opts?.responseOpts);
    };

    /**
     * Get chain metrics history.
     * Historical metrics for the chain
     */
    marketdataListMetricsV2ChainHistory({ metricId, chainId, timeStart, timeEnd, timeFormat, periodId, limit }: MarketdataListMetricsV2ChainHistoryRequest): Observable<Array<object>>
    marketdataListMetricsV2ChainHistory({ metricId, chainId, timeStart, timeEnd, timeFormat, periodId, limit }: MarketdataListMetricsV2ChainHistoryRequest, opts?: OperationOpts): Observable<AjaxResponse<Array<object>>>
    marketdataListMetricsV2ChainHistory({ metricId, chainId, timeStart, timeEnd, timeFormat, periodId, limit }: MarketdataListMetricsV2ChainHistoryRequest, opts?: OperationOpts): Observable<Array<object> | AjaxResponse<Array<object>>> {
        throwIfNullOrUndefined(metricId, 'metricId', 'marketdataListMetricsV2ChainHistory');
        throwIfNullOrUndefined(chainId, 'chainId', 'marketdataListMetricsV2ChainHistory');

        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // APIKey authentication
        };

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'metric_id': metricId,
            'chain_id': chainId,
        };

        if (timeStart != null) { query['time_start'] = (timeStart as any).toISOString(); }
        if (timeEnd != null) { query['time_end'] = (timeEnd as any).toISOString(); }
        if (timeFormat != null) { query['time_format'] = timeFormat; }
        if (periodId != null) { query['period_id'] = periodId; }
        if (limit != null) { query['limit'] = limit; }

        return this.request<Array<object>>({
            url: '/v2/metrics/chain/history',
            method: 'GET',
            headers,
            query,
        }, opts?.responseOpts);
    };

    /**
     * Get all metrics that are actually available for the specified blockchain chain.
     * Listing of metrics available for specific chain
     */
    marketdataListMetricsV2ChainListing({ chainId }: MarketdataListMetricsV2ChainListingRequest): Observable<Array<V1MetricInfo>>
    marketdataListMetricsV2ChainListing({ chainId }: MarketdataListMetricsV2ChainListingRequest, opts?: OperationOpts): Observable<AjaxResponse<Array<V1MetricInfo>>>
    marketdataListMetricsV2ChainListing({ chainId }: MarketdataListMetricsV2ChainListingRequest, opts?: OperationOpts): Observable<Array<V1MetricInfo> | AjaxResponse<Array<V1MetricInfo>>> {
        throwIfNullOrUndefined(chainId, 'chainId', 'marketdataListMetricsV2ChainListing');

        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // APIKey authentication
        };

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'chain_id': chainId,
        };

        return this.request<Array<V1MetricInfo>>({
            url: '/v2/metrics/chain/listing',
            method: 'GET',
            headers,
            query,
        }, opts?.responseOpts);
    };

    /**
     * Get exchange metrics history.
     * Historical metrics for the exchange
     */
    marketdataListMetricsV2ExchangeHistory({ metricId, exchangeId, timeStart, timeEnd, timeFormat, periodId, limit }: MarketdataListMetricsV2ExchangeHistoryRequest): Observable<Array<object>>
    marketdataListMetricsV2ExchangeHistory({ metricId, exchangeId, timeStart, timeEnd, timeFormat, periodId, limit }: MarketdataListMetricsV2ExchangeHistoryRequest, opts?: OperationOpts): Observable<AjaxResponse<Array<object>>>
    marketdataListMetricsV2ExchangeHistory({ metricId, exchangeId, timeStart, timeEnd, timeFormat, periodId, limit }: MarketdataListMetricsV2ExchangeHistoryRequest, opts?: OperationOpts): Observable<Array<object> | AjaxResponse<Array<object>>> {
        throwIfNullOrUndefined(metricId, 'metricId', 'marketdataListMetricsV2ExchangeHistory');
        throwIfNullOrUndefined(exchangeId, 'exchangeId', 'marketdataListMetricsV2ExchangeHistory');

        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // APIKey authentication
        };

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'metric_id': metricId,
            'exchange_id': exchangeId,
        };

        if (timeStart != null) { query['time_start'] = (timeStart as any).toISOString(); }
        if (timeEnd != null) { query['time_end'] = (timeEnd as any).toISOString(); }
        if (timeFormat != null) { query['time_format'] = timeFormat; }
        if (periodId != null) { query['period_id'] = periodId; }
        if (limit != null) { query['limit'] = limit; }

        return this.request<Array<object>>({
            url: '/v2/metrics/exchange/history',
            method: 'GET',
            headers,
            query,
        }, opts?.responseOpts);
    };

    /**
     * Get all metrics that are actually available for the specified exchange.
     * Listing of metrics available for specific exchange
     */
    marketdataListMetricsV2ExchangeListing({ exchangeId }: MarketdataListMetricsV2ExchangeListingRequest): Observable<Array<V1MetricInfo>>
    marketdataListMetricsV2ExchangeListing({ exchangeId }: MarketdataListMetricsV2ExchangeListingRequest, opts?: OperationOpts): Observable<AjaxResponse<Array<V1MetricInfo>>>
    marketdataListMetricsV2ExchangeListing({ exchangeId }: MarketdataListMetricsV2ExchangeListingRequest, opts?: OperationOpts): Observable<Array<V1MetricInfo> | AjaxResponse<Array<V1MetricInfo>>> {
        throwIfNullOrUndefined(exchangeId, 'exchangeId', 'marketdataListMetricsV2ExchangeListing');

        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // APIKey authentication
        };

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'exchange_id': exchangeId,
        };

        return this.request<Array<V1MetricInfo>>({
            url: '/v2/metrics/exchange/listing',
            method: 'GET',
            headers,
            query,
        }, opts?.responseOpts);
    };

    /**
     * Get all metrics available in the system.
     * Listing of all supported metrics
     */
    marketdataListMetricsV2Listing(): Observable<Array<V1MetricInfo>>
    marketdataListMetricsV2Listing(opts?: OperationOpts): Observable<AjaxResponse<Array<V1MetricInfo>>>
    marketdataListMetricsV2Listing(opts?: OperationOpts): Observable<Array<V1MetricInfo> | AjaxResponse<Array<V1MetricInfo>>> {
        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // APIKey authentication
        };

        return this.request<Array<V1MetricInfo>>({
            url: '/v2/metrics/listing',
            method: 'GET',
            headers,
        }, opts?.responseOpts);
    };

}
