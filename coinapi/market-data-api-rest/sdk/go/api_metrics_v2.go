/*
CoinAPI Market Data REST API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1
Contact: support@apibricks.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"time"
)


// MetricsV2APIService MetricsV2API service
type MetricsV2APIService service

type ApiMarketdataListMetricsV2AssetHistoryRequest struct {
	ctx context.Context
	ApiService *MetricsV2APIService
	metricId *string
	assetId *string
	timeStart *time.Time
	timeEnd *time.Time
	timeFormat *string
	periodId *string
	limit *int32
}

// Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60;)
func (r ApiMarketdataListMetricsV2AssetHistoryRequest) MetricId(metricId string) ApiMarketdataListMetricsV2AssetHistoryRequest {
	r.metricId = &metricId
	return r
}

// Asset identifier (e.g., &#x60;USDC&#x60;, &#x60;USDT&#x60;)
func (r ApiMarketdataListMetricsV2AssetHistoryRequest) AssetId(assetId string) ApiMarketdataListMetricsV2AssetHistoryRequest {
	r.assetId = &assetId
	return r
}

// Starting time in ISO 8601
func (r ApiMarketdataListMetricsV2AssetHistoryRequest) TimeStart(timeStart time.Time) ApiMarketdataListMetricsV2AssetHistoryRequest {
	r.timeStart = &timeStart
	return r
}

// Ending time in ISO 8601
func (r ApiMarketdataListMetricsV2AssetHistoryRequest) TimeEnd(timeEnd time.Time) ApiMarketdataListMetricsV2AssetHistoryRequest {
	r.timeEnd = &timeEnd
	return r
}

// If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)
func (r ApiMarketdataListMetricsV2AssetHistoryRequest) TimeFormat(timeFormat string) ApiMarketdataListMetricsV2AssetHistoryRequest {
	r.timeFormat = &timeFormat
	return r
}

// Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60;
func (r ApiMarketdataListMetricsV2AssetHistoryRequest) PeriodId(periodId string) ApiMarketdataListMetricsV2AssetHistoryRequest {
	r.periodId = &periodId
	return r
}

// Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)
func (r ApiMarketdataListMetricsV2AssetHistoryRequest) Limit(limit int32) ApiMarketdataListMetricsV2AssetHistoryRequest {
	r.limit = &limit
	return r
}

func (r ApiMarketdataListMetricsV2AssetHistoryRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.MarketdataListMetricsV2AssetHistoryExecute(r)
}

/*
MarketdataListMetricsV2AssetHistory Historical metrics for the asset

Get asset metrics history.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarketdataListMetricsV2AssetHistoryRequest
*/
func (a *MetricsV2APIService) MarketdataListMetricsV2AssetHistory(ctx context.Context) ApiMarketdataListMetricsV2AssetHistoryRequest {
	return ApiMarketdataListMetricsV2AssetHistoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *MetricsV2APIService) MarketdataListMetricsV2AssetHistoryExecute(r ApiMarketdataListMetricsV2AssetHistoryRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetricsV2APIService.MarketdataListMetricsV2AssetHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/metrics/asset/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.metricId == nil {
		return localVarReturnValue, nil, reportError("metricId is required and must be specified")
	}
	if r.assetId == nil {
		return localVarReturnValue, nil, reportError("assetId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "metric_id", r.metricId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "asset_id", r.assetId, "form", "")
	if r.timeStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_start", r.timeStart, "form", "")
	}
	if r.timeEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_end", r.timeEnd, "form", "")
	}
	if r.timeFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_format", r.timeFormat, "form", "")
	}
	if r.periodId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "period_id", r.periodId, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 100
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/x-msgpack"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarketdataListMetricsV2AssetListingRequest struct {
	ctx context.Context
	ApiService *MetricsV2APIService
	assetId *string
}

// Asset identifier (e.g., USDC, USDT)
func (r ApiMarketdataListMetricsV2AssetListingRequest) AssetId(assetId string) ApiMarketdataListMetricsV2AssetListingRequest {
	r.assetId = &assetId
	return r
}

func (r ApiMarketdataListMetricsV2AssetListingRequest) Execute() ([]V1MetricInfo, *http.Response, error) {
	return r.ApiService.MarketdataListMetricsV2AssetListingExecute(r)
}

/*
MarketdataListMetricsV2AssetListing Listing of metrics available for specific asset

Get all metrics that are actually available for the specified asset.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarketdataListMetricsV2AssetListingRequest
*/
func (a *MetricsV2APIService) MarketdataListMetricsV2AssetListing(ctx context.Context) ApiMarketdataListMetricsV2AssetListingRequest {
	return ApiMarketdataListMetricsV2AssetListingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []V1MetricInfo
func (a *MetricsV2APIService) MarketdataListMetricsV2AssetListingExecute(r ApiMarketdataListMetricsV2AssetListingRequest) ([]V1MetricInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []V1MetricInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetricsV2APIService.MarketdataListMetricsV2AssetListing")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/metrics/asset/listing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.assetId == nil {
		return localVarReturnValue, nil, reportError("assetId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "asset_id", r.assetId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/x-msgpack"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarketdataListMetricsV2ChainHistoryRequest struct {
	ctx context.Context
	ApiService *MetricsV2APIService
	metricId *string
	chainId *string
	timeStart *time.Time
	timeEnd *time.Time
	timeFormat *string
	periodId *string
	limit *int32
}

// Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60;)
func (r ApiMarketdataListMetricsV2ChainHistoryRequest) MetricId(metricId string) ApiMarketdataListMetricsV2ChainHistoryRequest {
	r.metricId = &metricId
	return r
}

// Chain identifier (e.g., &#x60;Ethereum&#x60;, &#x60;Arbitrum&#x60;)
func (r ApiMarketdataListMetricsV2ChainHistoryRequest) ChainId(chainId string) ApiMarketdataListMetricsV2ChainHistoryRequest {
	r.chainId = &chainId
	return r
}

// Starting time in ISO 8601
func (r ApiMarketdataListMetricsV2ChainHistoryRequest) TimeStart(timeStart time.Time) ApiMarketdataListMetricsV2ChainHistoryRequest {
	r.timeStart = &timeStart
	return r
}

// Ending time in ISO 8601
func (r ApiMarketdataListMetricsV2ChainHistoryRequest) TimeEnd(timeEnd time.Time) ApiMarketdataListMetricsV2ChainHistoryRequest {
	r.timeEnd = &timeEnd
	return r
}

// If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)
func (r ApiMarketdataListMetricsV2ChainHistoryRequest) TimeFormat(timeFormat string) ApiMarketdataListMetricsV2ChainHistoryRequest {
	r.timeFormat = &timeFormat
	return r
}

// Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60;
func (r ApiMarketdataListMetricsV2ChainHistoryRequest) PeriodId(periodId string) ApiMarketdataListMetricsV2ChainHistoryRequest {
	r.periodId = &periodId
	return r
}

// Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)
func (r ApiMarketdataListMetricsV2ChainHistoryRequest) Limit(limit int32) ApiMarketdataListMetricsV2ChainHistoryRequest {
	r.limit = &limit
	return r
}

func (r ApiMarketdataListMetricsV2ChainHistoryRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.MarketdataListMetricsV2ChainHistoryExecute(r)
}

/*
MarketdataListMetricsV2ChainHistory Historical metrics for the chain

Get chain metrics history.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarketdataListMetricsV2ChainHistoryRequest
*/
func (a *MetricsV2APIService) MarketdataListMetricsV2ChainHistory(ctx context.Context) ApiMarketdataListMetricsV2ChainHistoryRequest {
	return ApiMarketdataListMetricsV2ChainHistoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *MetricsV2APIService) MarketdataListMetricsV2ChainHistoryExecute(r ApiMarketdataListMetricsV2ChainHistoryRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetricsV2APIService.MarketdataListMetricsV2ChainHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/metrics/chain/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.metricId == nil {
		return localVarReturnValue, nil, reportError("metricId is required and must be specified")
	}
	if r.chainId == nil {
		return localVarReturnValue, nil, reportError("chainId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "metric_id", r.metricId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "chain_id", r.chainId, "form", "")
	if r.timeStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_start", r.timeStart, "form", "")
	}
	if r.timeEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_end", r.timeEnd, "form", "")
	}
	if r.timeFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_format", r.timeFormat, "form", "")
	}
	if r.periodId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "period_id", r.periodId, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 100
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/x-msgpack"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarketdataListMetricsV2ChainListingRequest struct {
	ctx context.Context
	ApiService *MetricsV2APIService
	chainId *string
}

// Chain identifier (e.g., ETHEREUM, ARBITRUM)
func (r ApiMarketdataListMetricsV2ChainListingRequest) ChainId(chainId string) ApiMarketdataListMetricsV2ChainListingRequest {
	r.chainId = &chainId
	return r
}

func (r ApiMarketdataListMetricsV2ChainListingRequest) Execute() ([]V1MetricInfo, *http.Response, error) {
	return r.ApiService.MarketdataListMetricsV2ChainListingExecute(r)
}

/*
MarketdataListMetricsV2ChainListing Listing of metrics available for specific chain

Get all metrics that are actually available for the specified blockchain chain.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarketdataListMetricsV2ChainListingRequest
*/
func (a *MetricsV2APIService) MarketdataListMetricsV2ChainListing(ctx context.Context) ApiMarketdataListMetricsV2ChainListingRequest {
	return ApiMarketdataListMetricsV2ChainListingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []V1MetricInfo
func (a *MetricsV2APIService) MarketdataListMetricsV2ChainListingExecute(r ApiMarketdataListMetricsV2ChainListingRequest) ([]V1MetricInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []V1MetricInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetricsV2APIService.MarketdataListMetricsV2ChainListing")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/metrics/chain/listing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chainId == nil {
		return localVarReturnValue, nil, reportError("chainId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "chain_id", r.chainId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/x-msgpack"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarketdataListMetricsV2ExchangeHistoryRequest struct {
	ctx context.Context
	ApiService *MetricsV2APIService
	metricId *string
	exchangeId *string
	timeStart *time.Time
	timeEnd *time.Time
	timeFormat *string
	periodId *string
	limit *int32
}

// Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60;)
func (r ApiMarketdataListMetricsV2ExchangeHistoryRequest) MetricId(metricId string) ApiMarketdataListMetricsV2ExchangeHistoryRequest {
	r.metricId = &metricId
	return r
}

// Exchange identifier (e.g., &#x60;BINANCE&#x60;, &#x60;UNISWAP-V3-ETHEREUM&#x60;)
func (r ApiMarketdataListMetricsV2ExchangeHistoryRequest) ExchangeId(exchangeId string) ApiMarketdataListMetricsV2ExchangeHistoryRequest {
	r.exchangeId = &exchangeId
	return r
}

// Starting time in ISO 8601
func (r ApiMarketdataListMetricsV2ExchangeHistoryRequest) TimeStart(timeStart time.Time) ApiMarketdataListMetricsV2ExchangeHistoryRequest {
	r.timeStart = &timeStart
	return r
}

// Ending time in ISO 8601
func (r ApiMarketdataListMetricsV2ExchangeHistoryRequest) TimeEnd(timeEnd time.Time) ApiMarketdataListMetricsV2ExchangeHistoryRequest {
	r.timeEnd = &timeEnd
	return r
}

// If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)
func (r ApiMarketdataListMetricsV2ExchangeHistoryRequest) TimeFormat(timeFormat string) ApiMarketdataListMetricsV2ExchangeHistoryRequest {
	r.timeFormat = &timeFormat
	return r
}

// Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60;
func (r ApiMarketdataListMetricsV2ExchangeHistoryRequest) PeriodId(periodId string) ApiMarketdataListMetricsV2ExchangeHistoryRequest {
	r.periodId = &periodId
	return r
}

// Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)
func (r ApiMarketdataListMetricsV2ExchangeHistoryRequest) Limit(limit int32) ApiMarketdataListMetricsV2ExchangeHistoryRequest {
	r.limit = &limit
	return r
}

func (r ApiMarketdataListMetricsV2ExchangeHistoryRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.MarketdataListMetricsV2ExchangeHistoryExecute(r)
}

/*
MarketdataListMetricsV2ExchangeHistory Historical metrics for the exchange

Get exchange metrics history.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarketdataListMetricsV2ExchangeHistoryRequest
*/
func (a *MetricsV2APIService) MarketdataListMetricsV2ExchangeHistory(ctx context.Context) ApiMarketdataListMetricsV2ExchangeHistoryRequest {
	return ApiMarketdataListMetricsV2ExchangeHistoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *MetricsV2APIService) MarketdataListMetricsV2ExchangeHistoryExecute(r ApiMarketdataListMetricsV2ExchangeHistoryRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetricsV2APIService.MarketdataListMetricsV2ExchangeHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/metrics/exchange/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.metricId == nil {
		return localVarReturnValue, nil, reportError("metricId is required and must be specified")
	}
	if r.exchangeId == nil {
		return localVarReturnValue, nil, reportError("exchangeId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "metric_id", r.metricId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "exchange_id", r.exchangeId, "form", "")
	if r.timeStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_start", r.timeStart, "form", "")
	}
	if r.timeEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_end", r.timeEnd, "form", "")
	}
	if r.timeFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_format", r.timeFormat, "form", "")
	}
	if r.periodId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "period_id", r.periodId, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 100
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/x-msgpack"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarketdataListMetricsV2ExchangeListingRequest struct {
	ctx context.Context
	ApiService *MetricsV2APIService
	exchangeId *string
}

// Exchange identifier (e.g., BINANCE, UNISWAP-V3-ETHEREUM)
func (r ApiMarketdataListMetricsV2ExchangeListingRequest) ExchangeId(exchangeId string) ApiMarketdataListMetricsV2ExchangeListingRequest {
	r.exchangeId = &exchangeId
	return r
}

func (r ApiMarketdataListMetricsV2ExchangeListingRequest) Execute() ([]V1MetricInfo, *http.Response, error) {
	return r.ApiService.MarketdataListMetricsV2ExchangeListingExecute(r)
}

/*
MarketdataListMetricsV2ExchangeListing Listing of metrics available for specific exchange

Get all metrics that are actually available for the specified exchange.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarketdataListMetricsV2ExchangeListingRequest
*/
func (a *MetricsV2APIService) MarketdataListMetricsV2ExchangeListing(ctx context.Context) ApiMarketdataListMetricsV2ExchangeListingRequest {
	return ApiMarketdataListMetricsV2ExchangeListingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []V1MetricInfo
func (a *MetricsV2APIService) MarketdataListMetricsV2ExchangeListingExecute(r ApiMarketdataListMetricsV2ExchangeListingRequest) ([]V1MetricInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []V1MetricInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetricsV2APIService.MarketdataListMetricsV2ExchangeListing")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/metrics/exchange/listing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.exchangeId == nil {
		return localVarReturnValue, nil, reportError("exchangeId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "exchange_id", r.exchangeId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/x-msgpack"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarketdataListMetricsV2ListingRequest struct {
	ctx context.Context
	ApiService *MetricsV2APIService
}

func (r ApiMarketdataListMetricsV2ListingRequest) Execute() ([]V1MetricInfo, *http.Response, error) {
	return r.ApiService.MarketdataListMetricsV2ListingExecute(r)
}

/*
MarketdataListMetricsV2Listing Listing of all supported metrics

Get all metrics available in the system.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarketdataListMetricsV2ListingRequest
*/
func (a *MetricsV2APIService) MarketdataListMetricsV2Listing(ctx context.Context) ApiMarketdataListMetricsV2ListingRequest {
	return ApiMarketdataListMetricsV2ListingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []V1MetricInfo
func (a *MetricsV2APIService) MarketdataListMetricsV2ListingExecute(r ApiMarketdataListMetricsV2ListingRequest) ([]V1MetricInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []V1MetricInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetricsV2APIService.MarketdataListMetricsV2Listing")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/metrics/listing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/x-msgpack"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
