#' CoinAPI Market Data REST API
#'
#' No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
#'
#' The version of the OpenAPI document: v1
#' Contact: support@apibricks.io
#' Generated by: https://openapi-generator.tech
#'
#' @docType class
#' @title MetricsV1 operations
#' @description MetricsV1Api
#' @format An \code{R6Class} generator object
#' @field api_client Handles the client-server communication.
#'
#' @examples
#' \dontrun{
#' ####################  V1MetricsAssetCurrentGet  ####################
#'
#' library(openapi)
#' var_metric_id <- "metric_id_example" # character | Metric identifier (from the Metrics -> Listing) (Optional)
#' var_asset_id <- "asset_id_example" # character | Asset identifier (from the Metadata -> Assets) (Optional)
#' var_asset_id_external <- "asset_id_external_example" # character | Exchange asset identifier (Optional)
#' var_exchange_id <- "exchange_id_example" # character | Exchange identifier (from the Metadata -> Exchanges) (Optional)
#'
#' #Current metrics for given asset
#' api_instance <- MetricsV1Api$new()
#'
#' # Configure API key authorization: APIKey
#' api_instance$api_client$api_keys["Authorization"] <- Sys.getenv("API_KEY")
#'
#' # Configure HTTP bearer authorization: JWT
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$V1MetricsAssetCurrentGet(metric_id = var_metric_id, asset_id = var_asset_id, asset_id_external = var_asset_id_external, exchange_id = var_exchange_iddata_file = "result.txt")
#' result <- api_instance$V1MetricsAssetCurrentGet(metric_id = var_metric_id, asset_id = var_asset_id, asset_id_external = var_asset_id_external, exchange_id = var_exchange_id)
#' dput(result)
#'
#'
#' ####################  V1MetricsAssetHistoryGet  ####################
#'
#' library(openapi)
#' var_metric_id <- "metric_id_example" # character | Metric identifier (from the Metrics -> Listing)
#' var_exchange_id <- "exchange_id_example" # character | Exchange identifier (from the Metadata -> Exchanges)
#' var_asset_id <- "asset_id_example" # character | Asset identifier (from the Metadata -> Assets) (Optional)
#' var_asset_id_external <- "asset_id_external_example" # character | Exchange asset identifier (Optional)
#' var_time_start <- "time_start_example" # character | Starting time in ISO 8601 (Optional)
#' var_time_end <- "time_end_example" # character | Ending time in ISO 8601 (Optional)
#' var_time_format <- "time_format_example" # character | If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (Optional)
#' var_period_id <- "period_id_example" # character | Identifier of requested timeseries period (e.g. `5SEC` or `2MTH`), default value is `1SEC` (Optional)
#' var_limit <- 100 # integer | Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (Optional)
#'
#' #Historical metrics for asset
#' api_instance <- MetricsV1Api$new()
#'
#' # Configure API key authorization: APIKey
#' api_instance$api_client$api_keys["Authorization"] <- Sys.getenv("API_KEY")
#'
#' # Configure HTTP bearer authorization: JWT
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$V1MetricsAssetHistoryGet(var_metric_id, var_exchange_id, asset_id = var_asset_id, asset_id_external = var_asset_id_external, time_start = var_time_start, time_end = var_time_end, time_format = var_time_format, period_id = var_period_id, limit = var_limitdata_file = "result.txt")
#' result <- api_instance$V1MetricsAssetHistoryGet(var_metric_id, var_exchange_id, asset_id = var_asset_id, asset_id_external = var_asset_id_external, time_start = var_time_start, time_end = var_time_end, time_format = var_time_format, period_id = var_period_id, limit = var_limit)
#' dput(result)
#'
#'
#' ####################  V1MetricsAssetListingGet  ####################
#'
#' library(openapi)
#' var_metric_id <- "metric_id_example" # character | Metric identifier (from the Metrics -> Listing) (Optional)
#' var_exchange_id <- "exchange_id_example" # character | Exchange identifier (from the Metadata -> Exchanges) (Optional)
#' var_chain_id <- "chain_id_example" # character | Chain identifier (Optional)
#' var_network_id <- "network_id_example" # character | Network identifier (Optional)
#' var_asset_id <- "asset_id_example" # character | Asset identifier (from the Metadata -> Assets) (Optional)
#' var_asset_id_external <- "asset_id_external_example" # character | The asset external identifier (Optional)
#'
#' #Listing of all supported metrics for asset
#' api_instance <- MetricsV1Api$new()
#'
#' # Configure API key authorization: APIKey
#' api_instance$api_client$api_keys["Authorization"] <- Sys.getenv("API_KEY")
#'
#' # Configure HTTP bearer authorization: JWT
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$V1MetricsAssetListingGet(metric_id = var_metric_id, exchange_id = var_exchange_id, chain_id = var_chain_id, network_id = var_network_id, asset_id = var_asset_id, asset_id_external = var_asset_id_externaldata_file = "result.txt")
#' result <- api_instance$V1MetricsAssetListingGet(metric_id = var_metric_id, exchange_id = var_exchange_id, chain_id = var_chain_id, network_id = var_network_id, asset_id = var_asset_id, asset_id_external = var_asset_id_external)
#' dput(result)
#'
#'
#' ####################  V1MetricsExchangeCurrentGet  ####################
#'
#' library(openapi)
#' var_exchange_id <- "exchange_id_example" # character | The exchange identifier (from the Metadata -> Exchanges)
#' var_metric_id <- "metric_id_example" # character | The metric identifier (from the Metrics -> Listing) (Optional)
#'
#' #Current metrics for given exchange
#' api_instance <- MetricsV1Api$new()
#'
#' # Configure API key authorization: APIKey
#' api_instance$api_client$api_keys["Authorization"] <- Sys.getenv("API_KEY")
#'
#' # Configure HTTP bearer authorization: JWT
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$V1MetricsExchangeCurrentGet(var_exchange_id, metric_id = var_metric_iddata_file = "result.txt")
#' result <- api_instance$V1MetricsExchangeCurrentGet(var_exchange_id, metric_id = var_metric_id)
#' dput(result)
#'
#'
#' ####################  V1MetricsExchangeHistoryGet  ####################
#'
#' library(openapi)
#' var_metric_id <- "metric_id_example" # character | Metric identifier (from the Metrics -> Listing)
#' var_exchange_id <- "exchange_id_example" # character | Exchange identifier (from the Metadata -> Exchanges)
#' var_time_start <- "time_start_example" # character | Starting time in ISO 8601 (Optional)
#' var_time_end <- "time_end_example" # character | Ending time in ISO 8601 (Optional)
#' var_time_format <- "time_format_example" # character | If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (Optional)
#' var_period_id <- "period_id_example" # character | Identifier of requested timeseries period (e.g. `5SEC` or `2MTH`), default value is `1SEC` (Optional)
#' var_limit <- 100 # integer | Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (Optional)
#'
#' #Historical metrics for the exchange
#' api_instance <- MetricsV1Api$new()
#'
#' # Configure API key authorization: APIKey
#' api_instance$api_client$api_keys["Authorization"] <- Sys.getenv("API_KEY")
#'
#' # Configure HTTP bearer authorization: JWT
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$V1MetricsExchangeHistoryGet(var_metric_id, var_exchange_id, time_start = var_time_start, time_end = var_time_end, time_format = var_time_format, period_id = var_period_id, limit = var_limitdata_file = "result.txt")
#' result <- api_instance$V1MetricsExchangeHistoryGet(var_metric_id, var_exchange_id, time_start = var_time_start, time_end = var_time_end, time_format = var_time_format, period_id = var_period_id, limit = var_limit)
#' dput(result)
#'
#'
#' ####################  V1MetricsExchangeListingGet  ####################
#'
#' library(openapi)
#' var_exchange_id <- "exchange_id_example" # character | The exchange identifier (from the Metadata -> Exchanges)
#' var_metric_id <- "metric_id_example" # character | The metric identifier (from the Metrics -> Listing) (Optional)
#'
#' #Listing of all supported exchange metrics
#' api_instance <- MetricsV1Api$new()
#'
#' # Configure API key authorization: APIKey
#' api_instance$api_client$api_keys["Authorization"] <- Sys.getenv("API_KEY")
#'
#' # Configure HTTP bearer authorization: JWT
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$V1MetricsExchangeListingGet(var_exchange_id, metric_id = var_metric_iddata_file = "result.txt")
#' result <- api_instance$V1MetricsExchangeListingGet(var_exchange_id, metric_id = var_metric_id)
#' dput(result)
#'
#'
#' ####################  V1MetricsListingGet  ####################
#'
#' library(openapi)
#'
#' #Listing of all supported metrics by CoinAPI
#' api_instance <- MetricsV1Api$new()
#'
#' # Configure API key authorization: APIKey
#' api_instance$api_client$api_keys["Authorization"] <- Sys.getenv("API_KEY")
#'
#' # Configure HTTP bearer authorization: JWT
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$V1MetricsListingGet(data_file = "result.txt")
#' result <- api_instance$V1MetricsListingGet()
#' dput(result)
#'
#'
#' ####################  V1MetricsSymbolCurrentGet  ####################
#'
#' library(openapi)
#' var_metric_id <- "metric_id_example" # character | Metric identifier (from the Metrics -> Listing) (Optional)
#' var_symbol_id <- "symbol_id_example" # character | Symbol identifier (from the Metadata -> Symbols) (Optional)
#' var_exchange_id <- "exchange_id_example" # character | Exchange id (from the Metadata -> Exchanges) (Optional)
#'
#' #Current metrics for given symbol
#' api_instance <- MetricsV1Api$new()
#'
#' # Configure API key authorization: APIKey
#' api_instance$api_client$api_keys["Authorization"] <- Sys.getenv("API_KEY")
#'
#' # Configure HTTP bearer authorization: JWT
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$V1MetricsSymbolCurrentGet(metric_id = var_metric_id, symbol_id = var_symbol_id, exchange_id = var_exchange_iddata_file = "result.txt")
#' result <- api_instance$V1MetricsSymbolCurrentGet(metric_id = var_metric_id, symbol_id = var_symbol_id, exchange_id = var_exchange_id)
#' dput(result)
#'
#'
#' ####################  V1MetricsSymbolHistoryGet  ####################
#'
#' library(openapi)
#' var_metric_id <- "metric_id_example" # character | Metric identifier (from the Metrics -> Listing)
#' var_symbol_id <- "symbol_id_example" # character | Symbol identifier (from the Metadata -> Symbols)
#' var_time_start <- "time_start_example" # character | Starting time in ISO 8601 (Optional)
#' var_time_end <- "time_end_example" # character | Ending time in ISO 8601 (Optional)
#' var_time_format <- "time_format_example" # character | If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (Optional)
#' var_period_id <- "period_id_example" # character | Identifier of requested timeseries period (e.g. `5SEC` or `2MTH`), default value is `1SEC` (Optional)
#' var_limit <- 100 # integer | Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (Optional)
#'
#' #Historical metrics for symbol
#' api_instance <- MetricsV1Api$new()
#'
#' # Configure API key authorization: APIKey
#' api_instance$api_client$api_keys["Authorization"] <- Sys.getenv("API_KEY")
#'
#' # Configure HTTP bearer authorization: JWT
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$V1MetricsSymbolHistoryGet(var_metric_id, var_symbol_id, time_start = var_time_start, time_end = var_time_end, time_format = var_time_format, period_id = var_period_id, limit = var_limitdata_file = "result.txt")
#' result <- api_instance$V1MetricsSymbolHistoryGet(var_metric_id, var_symbol_id, time_start = var_time_start, time_end = var_time_end, time_format = var_time_format, period_id = var_period_id, limit = var_limit)
#' dput(result)
#'
#'
#' ####################  V1MetricsSymbolListingGet  ####################
#'
#' library(openapi)
#' var_metric_id <- "metric_id_example" # character | Metric identifier (from the Metrics -> Listing) (Optional)
#' var_exchange_id <- "exchange_id_example" # character | Exchange identifier (from the Metadata -> Exchanges) (Optional)
#' var_symbol_id <- "symbol_id_example" # character | Symbol identifier (from the Metadata -> Symbols) (Optional)
#'
#' #Listing of all supported metrics for symbol
#' api_instance <- MetricsV1Api$new()
#'
#' # Configure API key authorization: APIKey
#' api_instance$api_client$api_keys["Authorization"] <- Sys.getenv("API_KEY")
#'
#' # Configure HTTP bearer authorization: JWT
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$V1MetricsSymbolListingGet(metric_id = var_metric_id, exchange_id = var_exchange_id, symbol_id = var_symbol_iddata_file = "result.txt")
#' result <- api_instance$V1MetricsSymbolListingGet(metric_id = var_metric_id, exchange_id = var_exchange_id, symbol_id = var_symbol_id)
#' dput(result)
#'
#'
#' }
#' @importFrom R6 R6Class
#' @importFrom base64enc base64encode
#' @export
MetricsV1Api <- R6::R6Class(
  "MetricsV1Api",
  public = list(
    api_client = NULL,

    #' @description
    #' Initialize a new MetricsV1Api.
    #'
    #' @param api_client An instance of API client.
    initialize = function(api_client) {
      if (!missing(api_client)) {
        self$api_client <- api_client
      } else {
        self$api_client <- ApiClient$new()
      }
    },

    #' @description
    #' Current metrics for given asset
    #'
    #' @param metric_id (optional) Metric identifier (from the Metrics -> Listing)
    #' @param asset_id (optional) Asset identifier (from the Metadata -> Assets)
    #' @param asset_id_external (optional) Exchange asset identifier
    #' @param exchange_id (optional) Exchange identifier (from the Metadata -> Exchanges)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return array[V1GeneralData]
    V1MetricsAssetCurrentGet = function(metric_id = NULL, asset_id = NULL, asset_id_external = NULL, exchange_id = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$V1MetricsAssetCurrentGetWithHttpInfo(metric_id, asset_id, asset_id_external, exchange_id, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Current metrics for given asset
    #'
    #' @param metric_id (optional) Metric identifier (from the Metrics -> Listing)
    #' @param asset_id (optional) Asset identifier (from the Metadata -> Assets)
    #' @param asset_id_external (optional) Exchange asset identifier
    #' @param exchange_id (optional) Exchange identifier (from the Metadata -> Exchanges)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (array[V1GeneralData]) with additional information such as HTTP status code, headers
    V1MetricsAssetCurrentGetWithHttpInfo = function(metric_id = NULL, asset_id = NULL, asset_id_external = NULL, exchange_id = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (!missing(`metric_id`) && is.null(`metric_id`)) {
        stop("Invalid value for `metric_id` when calling MetricsV1Api$V1MetricsAssetCurrentGet, `metric_id` is not nullable")
      }

      if (!missing(`asset_id`) && is.null(`asset_id`)) {
        stop("Invalid value for `asset_id` when calling MetricsV1Api$V1MetricsAssetCurrentGet, `asset_id` is not nullable")
      }

      if (!missing(`asset_id_external`) && is.null(`asset_id_external`)) {
        stop("Invalid value for `asset_id_external` when calling MetricsV1Api$V1MetricsAssetCurrentGet, `asset_id_external` is not nullable")
      }

      if (!missing(`exchange_id`) && is.null(`exchange_id`)) {
        stop("Invalid value for `exchange_id` when calling MetricsV1Api$V1MetricsAssetCurrentGet, `exchange_id` is not nullable")
      }

      query_params[["metric_id"]] <- `metric_id`

      query_params[["asset_id"]] <- `asset_id`

      query_params[["asset_id_external"]] <- `asset_id_external`

      query_params[["exchange_id"]] <- `exchange_id`

      local_var_url_path <- "/v1/metrics/asset/current"
      # API key authentication
      if ("Authorization" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["Authorization"]) > 0) {
        header_params["Authorization"] <- paste(unlist(self$api_client$api_keys["Authorization"]), collapse = "")
      }
      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/json", "text/json", "application/x-msgpack")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "array[V1GeneralData]"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Historical metrics for asset
    #'
    #' @param metric_id Metric identifier (from the Metrics -> Listing)
    #' @param exchange_id Exchange identifier (from the Metadata -> Exchanges)
    #' @param asset_id (optional) Asset identifier (from the Metadata -> Assets)
    #' @param asset_id_external (optional) Exchange asset identifier
    #' @param time_start (optional) Starting time in ISO 8601
    #' @param time_end (optional) Ending time in ISO 8601
    #' @param time_format (optional) If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)
    #' @param period_id (optional) Identifier of requested timeseries period (e.g. `5SEC` or `2MTH`), default value is `1SEC`
    #' @param limit (optional) Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (default value: 100)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return array[V1MetricData]
    V1MetricsAssetHistoryGet = function(metric_id, exchange_id, asset_id = NULL, asset_id_external = NULL, time_start = NULL, time_end = NULL, time_format = NULL, period_id = NULL, limit = 100, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$V1MetricsAssetHistoryGetWithHttpInfo(metric_id, exchange_id, asset_id, asset_id_external, time_start, time_end, time_format, period_id, limit, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Historical metrics for asset
    #'
    #' @param metric_id Metric identifier (from the Metrics -> Listing)
    #' @param exchange_id Exchange identifier (from the Metadata -> Exchanges)
    #' @param asset_id (optional) Asset identifier (from the Metadata -> Assets)
    #' @param asset_id_external (optional) Exchange asset identifier
    #' @param time_start (optional) Starting time in ISO 8601
    #' @param time_end (optional) Ending time in ISO 8601
    #' @param time_format (optional) If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)
    #' @param period_id (optional) Identifier of requested timeseries period (e.g. `5SEC` or `2MTH`), default value is `1SEC`
    #' @param limit (optional) Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (default value: 100)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (array[V1MetricData]) with additional information such as HTTP status code, headers
    V1MetricsAssetHistoryGetWithHttpInfo = function(metric_id, exchange_id, asset_id = NULL, asset_id_external = NULL, time_start = NULL, time_end = NULL, time_format = NULL, period_id = NULL, limit = 100, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`metric_id`)) {
        stop("Missing required parameter `metric_id`.")
      }

      if (missing(`exchange_id`)) {
        stop("Missing required parameter `exchange_id`.")
      }

      if (!missing(`metric_id`) && is.null(`metric_id`)) {
        stop("Invalid value for `metric_id` when calling MetricsV1Api$V1MetricsAssetHistoryGet, `metric_id` is not nullable")
      }

      if (!missing(`exchange_id`) && is.null(`exchange_id`)) {
        stop("Invalid value for `exchange_id` when calling MetricsV1Api$V1MetricsAssetHistoryGet, `exchange_id` is not nullable")
      }

      if (!missing(`asset_id`) && is.null(`asset_id`)) {
        stop("Invalid value for `asset_id` when calling MetricsV1Api$V1MetricsAssetHistoryGet, `asset_id` is not nullable")
      }

      if (!missing(`asset_id_external`) && is.null(`asset_id_external`)) {
        stop("Invalid value for `asset_id_external` when calling MetricsV1Api$V1MetricsAssetHistoryGet, `asset_id_external` is not nullable")
      }

      if (!missing(`time_start`) && is.null(`time_start`)) {
        stop("Invalid value for `time_start` when calling MetricsV1Api$V1MetricsAssetHistoryGet, `time_start` is not nullable")
      }

      if (!missing(`time_end`) && is.null(`time_end`)) {
        stop("Invalid value for `time_end` when calling MetricsV1Api$V1MetricsAssetHistoryGet, `time_end` is not nullable")
      }

      if (!missing(`time_format`) && is.null(`time_format`)) {
        stop("Invalid value for `time_format` when calling MetricsV1Api$V1MetricsAssetHistoryGet, `time_format` is not nullable")
      }

      if (!missing(`period_id`) && is.null(`period_id`)) {
        stop("Invalid value for `period_id` when calling MetricsV1Api$V1MetricsAssetHistoryGet, `period_id` is not nullable")
      }

      if (!missing(`limit`) && is.null(`limit`)) {
        stop("Invalid value for `limit` when calling MetricsV1Api$V1MetricsAssetHistoryGet, `limit` is not nullable")
      }

      query_params[["metric_id"]] <- `metric_id`

      query_params[["asset_id"]] <- `asset_id`

      query_params[["asset_id_external"]] <- `asset_id_external`

      query_params[["exchange_id"]] <- `exchange_id`

      query_params[["time_start"]] <- `time_start`

      query_params[["time_end"]] <- `time_end`

      query_params[["time_format"]] <- `time_format`

      query_params[["period_id"]] <- `period_id`

      query_params[["limit"]] <- `limit`

      local_var_url_path <- "/v1/metrics/asset/history"
      # API key authentication
      if ("Authorization" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["Authorization"]) > 0) {
        header_params["Authorization"] <- paste(unlist(self$api_client$api_keys["Authorization"]), collapse = "")
      }
      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/json", "text/json", "application/x-msgpack")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "array[V1MetricData]"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Listing of all supported metrics for asset
    #'
    #' @param metric_id (optional) Metric identifier (from the Metrics -> Listing)
    #' @param exchange_id (optional) Exchange identifier (from the Metadata -> Exchanges)
    #' @param chain_id (optional) Chain identifier
    #' @param network_id (optional) Network identifier
    #' @param asset_id (optional) Asset identifier (from the Metadata -> Assets)
    #' @param asset_id_external (optional) The asset external identifier
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return array[V1ListingItem]
    V1MetricsAssetListingGet = function(metric_id = NULL, exchange_id = NULL, chain_id = NULL, network_id = NULL, asset_id = NULL, asset_id_external = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$V1MetricsAssetListingGetWithHttpInfo(metric_id, exchange_id, chain_id, network_id, asset_id, asset_id_external, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Listing of all supported metrics for asset
    #'
    #' @param metric_id (optional) Metric identifier (from the Metrics -> Listing)
    #' @param exchange_id (optional) Exchange identifier (from the Metadata -> Exchanges)
    #' @param chain_id (optional) Chain identifier
    #' @param network_id (optional) Network identifier
    #' @param asset_id (optional) Asset identifier (from the Metadata -> Assets)
    #' @param asset_id_external (optional) The asset external identifier
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (array[V1ListingItem]) with additional information such as HTTP status code, headers
    V1MetricsAssetListingGetWithHttpInfo = function(metric_id = NULL, exchange_id = NULL, chain_id = NULL, network_id = NULL, asset_id = NULL, asset_id_external = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (!missing(`metric_id`) && is.null(`metric_id`)) {
        stop("Invalid value for `metric_id` when calling MetricsV1Api$V1MetricsAssetListingGet, `metric_id` is not nullable")
      }

      if (!missing(`exchange_id`) && is.null(`exchange_id`)) {
        stop("Invalid value for `exchange_id` when calling MetricsV1Api$V1MetricsAssetListingGet, `exchange_id` is not nullable")
      }

      if (!missing(`chain_id`) && is.null(`chain_id`)) {
        stop("Invalid value for `chain_id` when calling MetricsV1Api$V1MetricsAssetListingGet, `chain_id` is not nullable")
      }

      if (!missing(`network_id`) && is.null(`network_id`)) {
        stop("Invalid value for `network_id` when calling MetricsV1Api$V1MetricsAssetListingGet, `network_id` is not nullable")
      }

      if (!missing(`asset_id`) && is.null(`asset_id`)) {
        stop("Invalid value for `asset_id` when calling MetricsV1Api$V1MetricsAssetListingGet, `asset_id` is not nullable")
      }

      if (!missing(`asset_id_external`) && is.null(`asset_id_external`)) {
        stop("Invalid value for `asset_id_external` when calling MetricsV1Api$V1MetricsAssetListingGet, `asset_id_external` is not nullable")
      }

      query_params[["metric_id"]] <- `metric_id`

      query_params[["exchange_id"]] <- `exchange_id`

      query_params[["chain_id"]] <- `chain_id`

      query_params[["network_id"]] <- `network_id`

      query_params[["asset_id"]] <- `asset_id`

      query_params[["asset_id_external"]] <- `asset_id_external`

      local_var_url_path <- "/v1/metrics/asset/listing"
      # API key authentication
      if ("Authorization" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["Authorization"]) > 0) {
        header_params["Authorization"] <- paste(unlist(self$api_client$api_keys["Authorization"]), collapse = "")
      }
      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/json", "text/json", "application/x-msgpack")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "array[V1ListingItem]"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Current metrics for given exchange
    #'
    #' @param exchange_id The exchange identifier (from the Metadata -> Exchanges)
    #' @param metric_id (optional) The metric identifier (from the Metrics -> Listing)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return array[V1GeneralData]
    V1MetricsExchangeCurrentGet = function(exchange_id, metric_id = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$V1MetricsExchangeCurrentGetWithHttpInfo(exchange_id, metric_id, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Current metrics for given exchange
    #'
    #' @param exchange_id The exchange identifier (from the Metadata -> Exchanges)
    #' @param metric_id (optional) The metric identifier (from the Metrics -> Listing)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (array[V1GeneralData]) with additional information such as HTTP status code, headers
    V1MetricsExchangeCurrentGetWithHttpInfo = function(exchange_id, metric_id = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`exchange_id`)) {
        stop("Missing required parameter `exchange_id`.")
      }

      if (!missing(`exchange_id`) && is.null(`exchange_id`)) {
        stop("Invalid value for `exchange_id` when calling MetricsV1Api$V1MetricsExchangeCurrentGet, `exchange_id` is not nullable")
      }

      if (!missing(`metric_id`) && is.null(`metric_id`)) {
        stop("Invalid value for `metric_id` when calling MetricsV1Api$V1MetricsExchangeCurrentGet, `metric_id` is not nullable")
      }

      query_params[["metric_id"]] <- `metric_id`

      query_params[["exchange_id"]] <- `exchange_id`

      local_var_url_path <- "/v1/metrics/exchange/current"
      # API key authentication
      if ("Authorization" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["Authorization"]) > 0) {
        header_params["Authorization"] <- paste(unlist(self$api_client$api_keys["Authorization"]), collapse = "")
      }
      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/json", "text/json", "application/x-msgpack")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "array[V1GeneralData]"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Historical metrics for the exchange
    #'
    #' @param metric_id Metric identifier (from the Metrics -> Listing)
    #' @param exchange_id Exchange identifier (from the Metadata -> Exchanges)
    #' @param time_start (optional) Starting time in ISO 8601
    #' @param time_end (optional) Ending time in ISO 8601
    #' @param time_format (optional) If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)
    #' @param period_id (optional) Identifier of requested timeseries period (e.g. `5SEC` or `2MTH`), default value is `1SEC`
    #' @param limit (optional) Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (default value: 100)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return array[V1MetricData]
    V1MetricsExchangeHistoryGet = function(metric_id, exchange_id, time_start = NULL, time_end = NULL, time_format = NULL, period_id = NULL, limit = 100, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$V1MetricsExchangeHistoryGetWithHttpInfo(metric_id, exchange_id, time_start, time_end, time_format, period_id, limit, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Historical metrics for the exchange
    #'
    #' @param metric_id Metric identifier (from the Metrics -> Listing)
    #' @param exchange_id Exchange identifier (from the Metadata -> Exchanges)
    #' @param time_start (optional) Starting time in ISO 8601
    #' @param time_end (optional) Ending time in ISO 8601
    #' @param time_format (optional) If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)
    #' @param period_id (optional) Identifier of requested timeseries period (e.g. `5SEC` or `2MTH`), default value is `1SEC`
    #' @param limit (optional) Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (default value: 100)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (array[V1MetricData]) with additional information such as HTTP status code, headers
    V1MetricsExchangeHistoryGetWithHttpInfo = function(metric_id, exchange_id, time_start = NULL, time_end = NULL, time_format = NULL, period_id = NULL, limit = 100, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`metric_id`)) {
        stop("Missing required parameter `metric_id`.")
      }

      if (missing(`exchange_id`)) {
        stop("Missing required parameter `exchange_id`.")
      }

      if (!missing(`metric_id`) && is.null(`metric_id`)) {
        stop("Invalid value for `metric_id` when calling MetricsV1Api$V1MetricsExchangeHistoryGet, `metric_id` is not nullable")
      }

      if (!missing(`exchange_id`) && is.null(`exchange_id`)) {
        stop("Invalid value for `exchange_id` when calling MetricsV1Api$V1MetricsExchangeHistoryGet, `exchange_id` is not nullable")
      }

      if (!missing(`time_start`) && is.null(`time_start`)) {
        stop("Invalid value for `time_start` when calling MetricsV1Api$V1MetricsExchangeHistoryGet, `time_start` is not nullable")
      }

      if (!missing(`time_end`) && is.null(`time_end`)) {
        stop("Invalid value for `time_end` when calling MetricsV1Api$V1MetricsExchangeHistoryGet, `time_end` is not nullable")
      }

      if (!missing(`time_format`) && is.null(`time_format`)) {
        stop("Invalid value for `time_format` when calling MetricsV1Api$V1MetricsExchangeHistoryGet, `time_format` is not nullable")
      }

      if (!missing(`period_id`) && is.null(`period_id`)) {
        stop("Invalid value for `period_id` when calling MetricsV1Api$V1MetricsExchangeHistoryGet, `period_id` is not nullable")
      }

      if (!missing(`limit`) && is.null(`limit`)) {
        stop("Invalid value for `limit` when calling MetricsV1Api$V1MetricsExchangeHistoryGet, `limit` is not nullable")
      }

      query_params[["metric_id"]] <- `metric_id`

      query_params[["exchange_id"]] <- `exchange_id`

      query_params[["time_start"]] <- `time_start`

      query_params[["time_end"]] <- `time_end`

      query_params[["time_format"]] <- `time_format`

      query_params[["period_id"]] <- `period_id`

      query_params[["limit"]] <- `limit`

      local_var_url_path <- "/v1/metrics/exchange/history"
      # API key authentication
      if ("Authorization" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["Authorization"]) > 0) {
        header_params["Authorization"] <- paste(unlist(self$api_client$api_keys["Authorization"]), collapse = "")
      }
      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/json", "text/json", "application/x-msgpack")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "array[V1MetricData]"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Listing of all supported exchange metrics
    #'
    #' @param exchange_id The exchange identifier (from the Metadata -> Exchanges)
    #' @param metric_id (optional) The metric identifier (from the Metrics -> Listing)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return array[V1ListingItem]
    V1MetricsExchangeListingGet = function(exchange_id, metric_id = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$V1MetricsExchangeListingGetWithHttpInfo(exchange_id, metric_id, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Listing of all supported exchange metrics
    #'
    #' @param exchange_id The exchange identifier (from the Metadata -> Exchanges)
    #' @param metric_id (optional) The metric identifier (from the Metrics -> Listing)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (array[V1ListingItem]) with additional information such as HTTP status code, headers
    V1MetricsExchangeListingGetWithHttpInfo = function(exchange_id, metric_id = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`exchange_id`)) {
        stop("Missing required parameter `exchange_id`.")
      }

      if (!missing(`exchange_id`) && is.null(`exchange_id`)) {
        stop("Invalid value for `exchange_id` when calling MetricsV1Api$V1MetricsExchangeListingGet, `exchange_id` is not nullable")
      }

      if (!missing(`metric_id`) && is.null(`metric_id`)) {
        stop("Invalid value for `metric_id` when calling MetricsV1Api$V1MetricsExchangeListingGet, `metric_id` is not nullable")
      }

      query_params[["metric_id"]] <- `metric_id`

      query_params[["exchange_id"]] <- `exchange_id`

      local_var_url_path <- "/v1/metrics/exchange/listing"
      # API key authentication
      if ("Authorization" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["Authorization"]) > 0) {
        header_params["Authorization"] <- paste(unlist(self$api_client$api_keys["Authorization"]), collapse = "")
      }
      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/json", "text/json", "application/x-msgpack")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "array[V1ListingItem]"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Listing of all supported metrics by CoinAPI
    #'
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return array[V1Metric]
    V1MetricsListingGet = function(data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$V1MetricsListingGetWithHttpInfo(data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Listing of all supported metrics by CoinAPI
    #'
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (array[V1Metric]) with additional information such as HTTP status code, headers
    V1MetricsListingGetWithHttpInfo = function(data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      local_var_url_path <- "/v1/metrics/listing"
      # API key authentication
      if ("Authorization" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["Authorization"]) > 0) {
        header_params["Authorization"] <- paste(unlist(self$api_client$api_keys["Authorization"]), collapse = "")
      }
      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/json", "text/json", "application/x-msgpack")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "array[V1Metric]"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Current metrics for given symbol
    #'
    #' @param metric_id (optional) Metric identifier (from the Metrics -> Listing)
    #' @param symbol_id (optional) Symbol identifier (from the Metadata -> Symbols)
    #' @param exchange_id (optional) Exchange id (from the Metadata -> Exchanges)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return array[V1GeneralData]
    V1MetricsSymbolCurrentGet = function(metric_id = NULL, symbol_id = NULL, exchange_id = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$V1MetricsSymbolCurrentGetWithHttpInfo(metric_id, symbol_id, exchange_id, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Current metrics for given symbol
    #'
    #' @param metric_id (optional) Metric identifier (from the Metrics -> Listing)
    #' @param symbol_id (optional) Symbol identifier (from the Metadata -> Symbols)
    #' @param exchange_id (optional) Exchange id (from the Metadata -> Exchanges)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (array[V1GeneralData]) with additional information such as HTTP status code, headers
    V1MetricsSymbolCurrentGetWithHttpInfo = function(metric_id = NULL, symbol_id = NULL, exchange_id = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (!missing(`metric_id`) && is.null(`metric_id`)) {
        stop("Invalid value for `metric_id` when calling MetricsV1Api$V1MetricsSymbolCurrentGet, `metric_id` is not nullable")
      }

      if (!missing(`symbol_id`) && is.null(`symbol_id`)) {
        stop("Invalid value for `symbol_id` when calling MetricsV1Api$V1MetricsSymbolCurrentGet, `symbol_id` is not nullable")
      }

      if (!missing(`exchange_id`) && is.null(`exchange_id`)) {
        stop("Invalid value for `exchange_id` when calling MetricsV1Api$V1MetricsSymbolCurrentGet, `exchange_id` is not nullable")
      }

      query_params[["metric_id"]] <- `metric_id`

      query_params[["symbol_id"]] <- `symbol_id`

      query_params[["exchange_id"]] <- `exchange_id`

      local_var_url_path <- "/v1/metrics/symbol/current"
      # API key authentication
      if ("Authorization" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["Authorization"]) > 0) {
        header_params["Authorization"] <- paste(unlist(self$api_client$api_keys["Authorization"]), collapse = "")
      }
      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/json", "text/json", "application/x-msgpack")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "array[V1GeneralData]"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Historical metrics for symbol
    #'
    #' @param metric_id Metric identifier (from the Metrics -> Listing)
    #' @param symbol_id Symbol identifier (from the Metadata -> Symbols)
    #' @param time_start (optional) Starting time in ISO 8601
    #' @param time_end (optional) Ending time in ISO 8601
    #' @param time_format (optional) If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)
    #' @param period_id (optional) Identifier of requested timeseries period (e.g. `5SEC` or `2MTH`), default value is `1SEC`
    #' @param limit (optional) Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (default value: 100)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return array[V1MetricData]
    V1MetricsSymbolHistoryGet = function(metric_id, symbol_id, time_start = NULL, time_end = NULL, time_format = NULL, period_id = NULL, limit = 100, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$V1MetricsSymbolHistoryGetWithHttpInfo(metric_id, symbol_id, time_start, time_end, time_format, period_id, limit, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Historical metrics for symbol
    #'
    #' @param metric_id Metric identifier (from the Metrics -> Listing)
    #' @param symbol_id Symbol identifier (from the Metadata -> Symbols)
    #' @param time_start (optional) Starting time in ISO 8601
    #' @param time_end (optional) Ending time in ISO 8601
    #' @param time_format (optional) If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)
    #' @param period_id (optional) Identifier of requested timeseries period (e.g. `5SEC` or `2MTH`), default value is `1SEC`
    #' @param limit (optional) Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (default value: 100)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (array[V1MetricData]) with additional information such as HTTP status code, headers
    V1MetricsSymbolHistoryGetWithHttpInfo = function(metric_id, symbol_id, time_start = NULL, time_end = NULL, time_format = NULL, period_id = NULL, limit = 100, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`metric_id`)) {
        stop("Missing required parameter `metric_id`.")
      }

      if (missing(`symbol_id`)) {
        stop("Missing required parameter `symbol_id`.")
      }

      if (!missing(`metric_id`) && is.null(`metric_id`)) {
        stop("Invalid value for `metric_id` when calling MetricsV1Api$V1MetricsSymbolHistoryGet, `metric_id` is not nullable")
      }

      if (!missing(`symbol_id`) && is.null(`symbol_id`)) {
        stop("Invalid value for `symbol_id` when calling MetricsV1Api$V1MetricsSymbolHistoryGet, `symbol_id` is not nullable")
      }

      if (!missing(`time_start`) && is.null(`time_start`)) {
        stop("Invalid value for `time_start` when calling MetricsV1Api$V1MetricsSymbolHistoryGet, `time_start` is not nullable")
      }

      if (!missing(`time_end`) && is.null(`time_end`)) {
        stop("Invalid value for `time_end` when calling MetricsV1Api$V1MetricsSymbolHistoryGet, `time_end` is not nullable")
      }

      if (!missing(`time_format`) && is.null(`time_format`)) {
        stop("Invalid value for `time_format` when calling MetricsV1Api$V1MetricsSymbolHistoryGet, `time_format` is not nullable")
      }

      if (!missing(`period_id`) && is.null(`period_id`)) {
        stop("Invalid value for `period_id` when calling MetricsV1Api$V1MetricsSymbolHistoryGet, `period_id` is not nullable")
      }

      if (!missing(`limit`) && is.null(`limit`)) {
        stop("Invalid value for `limit` when calling MetricsV1Api$V1MetricsSymbolHistoryGet, `limit` is not nullable")
      }

      query_params[["metric_id"]] <- `metric_id`

      query_params[["symbol_id"]] <- `symbol_id`

      query_params[["time_start"]] <- `time_start`

      query_params[["time_end"]] <- `time_end`

      query_params[["time_format"]] <- `time_format`

      query_params[["period_id"]] <- `period_id`

      query_params[["limit"]] <- `limit`

      local_var_url_path <- "/v1/metrics/symbol/history"
      # API key authentication
      if ("Authorization" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["Authorization"]) > 0) {
        header_params["Authorization"] <- paste(unlist(self$api_client$api_keys["Authorization"]), collapse = "")
      }
      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/json", "text/json", "application/x-msgpack")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "array[V1MetricData]"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Listing of all supported metrics for symbol
    #'
    #' @param metric_id (optional) Metric identifier (from the Metrics -> Listing)
    #' @param exchange_id (optional) Exchange identifier (from the Metadata -> Exchanges)
    #' @param symbol_id (optional) Symbol identifier (from the Metadata -> Symbols)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return array[V1ListingItem]
    V1MetricsSymbolListingGet = function(metric_id = NULL, exchange_id = NULL, symbol_id = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$V1MetricsSymbolListingGetWithHttpInfo(metric_id, exchange_id, symbol_id, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Listing of all supported metrics for symbol
    #'
    #' @param metric_id (optional) Metric identifier (from the Metrics -> Listing)
    #' @param exchange_id (optional) Exchange identifier (from the Metadata -> Exchanges)
    #' @param symbol_id (optional) Symbol identifier (from the Metadata -> Symbols)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (array[V1ListingItem]) with additional information such as HTTP status code, headers
    V1MetricsSymbolListingGetWithHttpInfo = function(metric_id = NULL, exchange_id = NULL, symbol_id = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (!missing(`metric_id`) && is.null(`metric_id`)) {
        stop("Invalid value for `metric_id` when calling MetricsV1Api$V1MetricsSymbolListingGet, `metric_id` is not nullable")
      }

      if (!missing(`exchange_id`) && is.null(`exchange_id`)) {
        stop("Invalid value for `exchange_id` when calling MetricsV1Api$V1MetricsSymbolListingGet, `exchange_id` is not nullable")
      }

      if (!missing(`symbol_id`) && is.null(`symbol_id`)) {
        stop("Invalid value for `symbol_id` when calling MetricsV1Api$V1MetricsSymbolListingGet, `symbol_id` is not nullable")
      }

      query_params[["metric_id"]] <- `metric_id`

      query_params[["exchange_id"]] <- `exchange_id`

      query_params[["symbol_id"]] <- `symbol_id`

      local_var_url_path <- "/v1/metrics/symbol/listing"
      # API key authentication
      if ("Authorization" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["Authorization"]) > 0) {
        header_params["Authorization"] <- paste(unlist(self$api_client$api_keys["Authorization"]), collapse = "")
      }
      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/json", "text/json", "application/x-msgpack")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "array[V1ListingItem]"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    }
  )
)
