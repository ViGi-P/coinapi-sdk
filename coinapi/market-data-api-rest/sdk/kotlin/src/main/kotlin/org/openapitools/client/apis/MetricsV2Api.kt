/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.V1MetricInfo

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

open class MetricsV2Api(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://rest.coinapi.io")
        }
    }

    /**
     * GET /v2/metrics/asset/history
     * Historical metrics for the asset
     * Get asset metrics history.
     * @param metricId Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60;)
     * @param assetId Asset identifier (e.g., &#x60;USDC&#x60;, &#x60;USDT&#x60;)
     * @param timeStart Starting time in ISO 8601 (optional)
     * @param timeEnd Ending time in ISO 8601 (optional)
     * @param timeFormat If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)
     * @param periodId Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60; (optional)
     * @param limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @return kotlin.collections.List<kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun marketdataListMetricsV2AssetHistory(metricId: kotlin.String, assetId: kotlin.String, timeStart: java.time.OffsetDateTime? = null, timeEnd: java.time.OffsetDateTime? = null, timeFormat: kotlin.String? = null, periodId: kotlin.String? = null, limit: kotlin.Int? = 100) : kotlin.collections.List<kotlin.Any> {
        val localVarResponse = marketdataListMetricsV2AssetHistoryWithHttpInfo(metricId = metricId, assetId = assetId, timeStart = timeStart, timeEnd = timeEnd, timeFormat = timeFormat, periodId = periodId, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/metrics/asset/history
     * Historical metrics for the asset
     * Get asset metrics history.
     * @param metricId Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60;)
     * @param assetId Asset identifier (e.g., &#x60;USDC&#x60;, &#x60;USDT&#x60;)
     * @param timeStart Starting time in ISO 8601 (optional)
     * @param timeEnd Ending time in ISO 8601 (optional)
     * @param timeFormat If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)
     * @param periodId Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60; (optional)
     * @param limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @return ApiResponse<kotlin.collections.List<kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun marketdataListMetricsV2AssetHistoryWithHttpInfo(metricId: kotlin.String, assetId: kotlin.String, timeStart: java.time.OffsetDateTime?, timeEnd: java.time.OffsetDateTime?, timeFormat: kotlin.String?, periodId: kotlin.String?, limit: kotlin.Int?) : ApiResponse<kotlin.collections.List<kotlin.Any>?> {
        val localVariableConfig = marketdataListMetricsV2AssetHistoryRequestConfig(metricId = metricId, assetId = assetId, timeStart = timeStart, timeEnd = timeEnd, timeFormat = timeFormat, periodId = periodId, limit = limit)

        return request<Unit, kotlin.collections.List<kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation marketdataListMetricsV2AssetHistory
     *
     * @param metricId Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60;)
     * @param assetId Asset identifier (e.g., &#x60;USDC&#x60;, &#x60;USDT&#x60;)
     * @param timeStart Starting time in ISO 8601 (optional)
     * @param timeEnd Ending time in ISO 8601 (optional)
     * @param timeFormat If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)
     * @param periodId Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60; (optional)
     * @param limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @return RequestConfig
     */
    fun marketdataListMetricsV2AssetHistoryRequestConfig(metricId: kotlin.String, assetId: kotlin.String, timeStart: java.time.OffsetDateTime?, timeEnd: java.time.OffsetDateTime?, timeFormat: kotlin.String?, periodId: kotlin.String?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("metric_id", listOf(metricId.toString()))
                put("asset_id", listOf(assetId.toString()))
                if (timeStart != null) {
                    put("time_start", listOf(parseDateToQueryString(timeStart)))
                }
                if (timeEnd != null) {
                    put("time_end", listOf(parseDateToQueryString(timeEnd)))
                }
                if (timeFormat != null) {
                    put("time_format", listOf(timeFormat.toString()))
                }
                if (periodId != null) {
                    put("period_id", listOf(periodId.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "text/plain, application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/metrics/asset/history",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/metrics/asset/listing
     * Listing of metrics available for specific asset
     * Get all metrics that are actually available for the specified asset.
     * @param assetId Asset identifier (e.g., USDC, USDT)
     * @return kotlin.collections.List<V1MetricInfo>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun marketdataListMetricsV2AssetListing(assetId: kotlin.String) : kotlin.collections.List<V1MetricInfo> {
        val localVarResponse = marketdataListMetricsV2AssetListingWithHttpInfo(assetId = assetId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<V1MetricInfo>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/metrics/asset/listing
     * Listing of metrics available for specific asset
     * Get all metrics that are actually available for the specified asset.
     * @param assetId Asset identifier (e.g., USDC, USDT)
     * @return ApiResponse<kotlin.collections.List<V1MetricInfo>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun marketdataListMetricsV2AssetListingWithHttpInfo(assetId: kotlin.String) : ApiResponse<kotlin.collections.List<V1MetricInfo>?> {
        val localVariableConfig = marketdataListMetricsV2AssetListingRequestConfig(assetId = assetId)

        return request<Unit, kotlin.collections.List<V1MetricInfo>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation marketdataListMetricsV2AssetListing
     *
     * @param assetId Asset identifier (e.g., USDC, USDT)
     * @return RequestConfig
     */
    fun marketdataListMetricsV2AssetListingRequestConfig(assetId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("asset_id", listOf(assetId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "text/plain, application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/metrics/asset/listing",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/metrics/chain/history
     * Historical metrics for the chain
     * Get chain metrics history.
     * @param metricId Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60;)
     * @param chainId Chain identifier (e.g., &#x60;Ethereum&#x60;, &#x60;Arbitrum&#x60;)
     * @param timeStart Starting time in ISO 8601 (optional)
     * @param timeEnd Ending time in ISO 8601 (optional)
     * @param timeFormat If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)
     * @param periodId Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60; (optional)
     * @param limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @return kotlin.collections.List<kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun marketdataListMetricsV2ChainHistory(metricId: kotlin.String, chainId: kotlin.String, timeStart: java.time.OffsetDateTime? = null, timeEnd: java.time.OffsetDateTime? = null, timeFormat: kotlin.String? = null, periodId: kotlin.String? = null, limit: kotlin.Int? = 100) : kotlin.collections.List<kotlin.Any> {
        val localVarResponse = marketdataListMetricsV2ChainHistoryWithHttpInfo(metricId = metricId, chainId = chainId, timeStart = timeStart, timeEnd = timeEnd, timeFormat = timeFormat, periodId = periodId, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/metrics/chain/history
     * Historical metrics for the chain
     * Get chain metrics history.
     * @param metricId Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60;)
     * @param chainId Chain identifier (e.g., &#x60;Ethereum&#x60;, &#x60;Arbitrum&#x60;)
     * @param timeStart Starting time in ISO 8601 (optional)
     * @param timeEnd Ending time in ISO 8601 (optional)
     * @param timeFormat If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)
     * @param periodId Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60; (optional)
     * @param limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @return ApiResponse<kotlin.collections.List<kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun marketdataListMetricsV2ChainHistoryWithHttpInfo(metricId: kotlin.String, chainId: kotlin.String, timeStart: java.time.OffsetDateTime?, timeEnd: java.time.OffsetDateTime?, timeFormat: kotlin.String?, periodId: kotlin.String?, limit: kotlin.Int?) : ApiResponse<kotlin.collections.List<kotlin.Any>?> {
        val localVariableConfig = marketdataListMetricsV2ChainHistoryRequestConfig(metricId = metricId, chainId = chainId, timeStart = timeStart, timeEnd = timeEnd, timeFormat = timeFormat, periodId = periodId, limit = limit)

        return request<Unit, kotlin.collections.List<kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation marketdataListMetricsV2ChainHistory
     *
     * @param metricId Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60;)
     * @param chainId Chain identifier (e.g., &#x60;Ethereum&#x60;, &#x60;Arbitrum&#x60;)
     * @param timeStart Starting time in ISO 8601 (optional)
     * @param timeEnd Ending time in ISO 8601 (optional)
     * @param timeFormat If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)
     * @param periodId Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60; (optional)
     * @param limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @return RequestConfig
     */
    fun marketdataListMetricsV2ChainHistoryRequestConfig(metricId: kotlin.String, chainId: kotlin.String, timeStart: java.time.OffsetDateTime?, timeEnd: java.time.OffsetDateTime?, timeFormat: kotlin.String?, periodId: kotlin.String?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("metric_id", listOf(metricId.toString()))
                put("chain_id", listOf(chainId.toString()))
                if (timeStart != null) {
                    put("time_start", listOf(parseDateToQueryString(timeStart)))
                }
                if (timeEnd != null) {
                    put("time_end", listOf(parseDateToQueryString(timeEnd)))
                }
                if (timeFormat != null) {
                    put("time_format", listOf(timeFormat.toString()))
                }
                if (periodId != null) {
                    put("period_id", listOf(periodId.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "text/plain, application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/metrics/chain/history",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/metrics/chain/listing
     * Listing of metrics available for specific chain
     * Get all metrics that are actually available for the specified blockchain chain.
     * @param chainId Chain identifier (e.g., ETHEREUM, ARBITRUM)
     * @return kotlin.collections.List<V1MetricInfo>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun marketdataListMetricsV2ChainListing(chainId: kotlin.String) : kotlin.collections.List<V1MetricInfo> {
        val localVarResponse = marketdataListMetricsV2ChainListingWithHttpInfo(chainId = chainId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<V1MetricInfo>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/metrics/chain/listing
     * Listing of metrics available for specific chain
     * Get all metrics that are actually available for the specified blockchain chain.
     * @param chainId Chain identifier (e.g., ETHEREUM, ARBITRUM)
     * @return ApiResponse<kotlin.collections.List<V1MetricInfo>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun marketdataListMetricsV2ChainListingWithHttpInfo(chainId: kotlin.String) : ApiResponse<kotlin.collections.List<V1MetricInfo>?> {
        val localVariableConfig = marketdataListMetricsV2ChainListingRequestConfig(chainId = chainId)

        return request<Unit, kotlin.collections.List<V1MetricInfo>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation marketdataListMetricsV2ChainListing
     *
     * @param chainId Chain identifier (e.g., ETHEREUM, ARBITRUM)
     * @return RequestConfig
     */
    fun marketdataListMetricsV2ChainListingRequestConfig(chainId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("chain_id", listOf(chainId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "text/plain, application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/metrics/chain/listing",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/metrics/exchange/history
     * Historical metrics for the exchange
     * Get exchange metrics history.
     * @param metricId Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60;)
     * @param exchangeId Exchange identifier (e.g., &#x60;BINANCE&#x60;, &#x60;UNISWAP-V3-ETHEREUM&#x60;)
     * @param timeStart Starting time in ISO 8601 (optional)
     * @param timeEnd Ending time in ISO 8601 (optional)
     * @param timeFormat If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)
     * @param periodId Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60; (optional)
     * @param limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @return kotlin.collections.List<kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun marketdataListMetricsV2ExchangeHistory(metricId: kotlin.String, exchangeId: kotlin.String, timeStart: java.time.OffsetDateTime? = null, timeEnd: java.time.OffsetDateTime? = null, timeFormat: kotlin.String? = null, periodId: kotlin.String? = null, limit: kotlin.Int? = 100) : kotlin.collections.List<kotlin.Any> {
        val localVarResponse = marketdataListMetricsV2ExchangeHistoryWithHttpInfo(metricId = metricId, exchangeId = exchangeId, timeStart = timeStart, timeEnd = timeEnd, timeFormat = timeFormat, periodId = periodId, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/metrics/exchange/history
     * Historical metrics for the exchange
     * Get exchange metrics history.
     * @param metricId Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60;)
     * @param exchangeId Exchange identifier (e.g., &#x60;BINANCE&#x60;, &#x60;UNISWAP-V3-ETHEREUM&#x60;)
     * @param timeStart Starting time in ISO 8601 (optional)
     * @param timeEnd Ending time in ISO 8601 (optional)
     * @param timeFormat If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)
     * @param periodId Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60; (optional)
     * @param limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @return ApiResponse<kotlin.collections.List<kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun marketdataListMetricsV2ExchangeHistoryWithHttpInfo(metricId: kotlin.String, exchangeId: kotlin.String, timeStart: java.time.OffsetDateTime?, timeEnd: java.time.OffsetDateTime?, timeFormat: kotlin.String?, periodId: kotlin.String?, limit: kotlin.Int?) : ApiResponse<kotlin.collections.List<kotlin.Any>?> {
        val localVariableConfig = marketdataListMetricsV2ExchangeHistoryRequestConfig(metricId = metricId, exchangeId = exchangeId, timeStart = timeStart, timeEnd = timeEnd, timeFormat = timeFormat, periodId = periodId, limit = limit)

        return request<Unit, kotlin.collections.List<kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation marketdataListMetricsV2ExchangeHistory
     *
     * @param metricId Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60;)
     * @param exchangeId Exchange identifier (e.g., &#x60;BINANCE&#x60;, &#x60;UNISWAP-V3-ETHEREUM&#x60;)
     * @param timeStart Starting time in ISO 8601 (optional)
     * @param timeEnd Ending time in ISO 8601 (optional)
     * @param timeFormat If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)
     * @param periodId Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60; (optional)
     * @param limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @return RequestConfig
     */
    fun marketdataListMetricsV2ExchangeHistoryRequestConfig(metricId: kotlin.String, exchangeId: kotlin.String, timeStart: java.time.OffsetDateTime?, timeEnd: java.time.OffsetDateTime?, timeFormat: kotlin.String?, periodId: kotlin.String?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("metric_id", listOf(metricId.toString()))
                put("exchange_id", listOf(exchangeId.toString()))
                if (timeStart != null) {
                    put("time_start", listOf(parseDateToQueryString(timeStart)))
                }
                if (timeEnd != null) {
                    put("time_end", listOf(parseDateToQueryString(timeEnd)))
                }
                if (timeFormat != null) {
                    put("time_format", listOf(timeFormat.toString()))
                }
                if (periodId != null) {
                    put("period_id", listOf(periodId.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "text/plain, application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/metrics/exchange/history",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/metrics/exchange/listing
     * Listing of metrics available for specific exchange
     * Get all metrics that are actually available for the specified exchange.
     * @param exchangeId Exchange identifier (e.g., BINANCE, UNISWAP-V3-ETHEREUM)
     * @return kotlin.collections.List<V1MetricInfo>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun marketdataListMetricsV2ExchangeListing(exchangeId: kotlin.String) : kotlin.collections.List<V1MetricInfo> {
        val localVarResponse = marketdataListMetricsV2ExchangeListingWithHttpInfo(exchangeId = exchangeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<V1MetricInfo>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/metrics/exchange/listing
     * Listing of metrics available for specific exchange
     * Get all metrics that are actually available for the specified exchange.
     * @param exchangeId Exchange identifier (e.g., BINANCE, UNISWAP-V3-ETHEREUM)
     * @return ApiResponse<kotlin.collections.List<V1MetricInfo>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun marketdataListMetricsV2ExchangeListingWithHttpInfo(exchangeId: kotlin.String) : ApiResponse<kotlin.collections.List<V1MetricInfo>?> {
        val localVariableConfig = marketdataListMetricsV2ExchangeListingRequestConfig(exchangeId = exchangeId)

        return request<Unit, kotlin.collections.List<V1MetricInfo>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation marketdataListMetricsV2ExchangeListing
     *
     * @param exchangeId Exchange identifier (e.g., BINANCE, UNISWAP-V3-ETHEREUM)
     * @return RequestConfig
     */
    fun marketdataListMetricsV2ExchangeListingRequestConfig(exchangeId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("exchange_id", listOf(exchangeId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "text/plain, application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/metrics/exchange/listing",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/metrics/listing
     * Listing of all supported metrics
     * Get all metrics available in the system.
     * @return kotlin.collections.List<V1MetricInfo>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun marketdataListMetricsV2Listing() : kotlin.collections.List<V1MetricInfo> {
        val localVarResponse = marketdataListMetricsV2ListingWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<V1MetricInfo>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/metrics/listing
     * Listing of all supported metrics
     * Get all metrics available in the system.
     * @return ApiResponse<kotlin.collections.List<V1MetricInfo>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun marketdataListMetricsV2ListingWithHttpInfo() : ApiResponse<kotlin.collections.List<V1MetricInfo>?> {
        val localVariableConfig = marketdataListMetricsV2ListingRequestConfig()

        return request<Unit, kotlin.collections.List<V1MetricInfo>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation marketdataListMetricsV2Listing
     *
     * @return RequestConfig
     */
    fun marketdataListMetricsV2ListingRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "text/plain, application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/metrics/listing",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
